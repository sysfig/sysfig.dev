<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sysfig</title><link>https://sysfig.dev/</link><description>Recent content on sysfig</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Mon, 04 Jan 2021 07:26:25 -0800</lastBuildDate><atom:link href="https://sysfig.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>E2E Tests are the Most Important</title><link>https://sysfig.dev/series/hobgoblins-of-little-minds/e2e-tests-most-important/</link><pubDate>Mon, 04 Jan 2021 07:26:25 -0800</pubDate><guid>https://sysfig.dev/series/hobgoblins-of-little-minds/e2e-tests-most-important/</guid><description>End-to-End (E2E) tests are the most important tests for a piece of software because they are the technical implementation of the contract between the software creator and its users. If all your E2E tests pass, then the contract is fulfilled.
Linus Torvalds, the creator and maintainer of Linux, one of the biggest open-source projects, famously said &amp;ldquo;WE DO NOT BREAK USERSPACE!&amp;rdquo; (an opinion which he consistently expresses). He values:
Not breaking the contract between the kernel and user-space programs Don&amp;rsquo;t make changes to the contact that&amp;rsquo;s incompatible with previous contracts Now, I&amp;rsquo;d bet the software you&amp;rsquo;re writing have fewer dependents than the Linux kernel, and you can change the contract more freely, but the purpose of this article is to drill home the point that you should not break contracts.</description></item><item><title>The Allure of New</title><link>https://sysfig.dev/series/hobgoblins-of-little-minds/allure-of-new/</link><pubDate>Thu, 31 Dec 2020 21:02:44 -0800</pubDate><guid>https://sysfig.dev/series/hobgoblins-of-little-minds/allure-of-new/</guid><description>People like new things.
When a developer sees a new technology (let&amp;rsquo;s call it X) on a job description page, or noticed X popping up as a topic on recent Meetups, they may try to convince their managers to use it at work so they can learn it and have experience with it. I mean, who doesn&amp;rsquo;t want 12 years of Kubernetes experience? (You got to get in early!)
But using new technologies is risky.</description></item><item><title>There are No Gods</title><link>https://sysfig.dev/series/hobgoblins-of-little-minds/there-are-no-gods/</link><pubDate>Thu, 31 Dec 2020 17:39:12 -0800</pubDate><guid>https://sysfig.dev/series/hobgoblins-of-little-minds/there-are-no-gods/</guid><description>In many of the companies I&amp;rsquo;ve worked at, there was often one or two developers that everyone hails as an untouchable God with a gifted mind for code. They are usually one of the early hires who&amp;rsquo;ve established a reputation and newcomers just accept it as fact.
Most of the time, this God perception is formed because colleagues are afraid to ask them questions. And they don&amp;rsquo;t ask questions, more often than not, because there&amp;rsquo;s a culture that sees asking (potentially &amp;lsquo;dumb&amp;rsquo;) questions as a sign of weakness.</description></item><item><title>10% Done</title><link>https://sysfig.dev/series/hobgoblins-of-little-minds/10-percent-done/</link><pubDate>Thu, 31 Dec 2020 16:31:04 -0800</pubDate><guid>https://sysfig.dev/series/hobgoblins-of-little-minds/10-percent-done/</guid><description>We often talk about the goal of software engineering as &amp;ldquo;writing applications that work&amp;rdquo;. But, in truth, that&amp;rsquo;s only 10% of it.
It&amp;rsquo;s easy to write a simple clone of Facebook, Amazon, or Airbnb on your own and deploy it on server; but it&amp;rsquo;s difficult to develop a system where many developers can work together effortlessly (distributed version control, code review pair programming), where new features can be added, tested, and deployed quickly (continuous integration, continuous deployment), where developers can be confident things work (tests), where bugs can be detected and resolved quickly (logging, monitoring), where a new developer joining the project can get up to speed quickly (documentation), where the code is performant (benchmarking).</description></item><item><title>Projects</title><link>https://sysfig.dev/projects/</link><pubDate>Sun, 27 Dec 2020 20:58:45 -0800</pubDate><guid>https://sysfig.dev/projects/</guid><description>Coming soon!</description></item><item><title>Now</title><link>https://sysfig.dev/now/</link><pubDate>Wed, 09 Dec 2020 20:48:46 -0800</pubDate><guid>https://sysfig.dev/now/</guid><description>This is a now page.
Quit my job to work on [REDACTED] - a learning platform that makes learning fun and accessible to all. Learning Hugo and making this site</description></item><item><title/><link>https://sysfig.dev/series/c++/z00_dump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/c++/z00_dump/</guid><description/></item><item><title/><link>https://sysfig.dev/series/c++/z00_testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/c++/z00_testing/</guid><description>googletest https://github.com/google/googletest https://github.com/google/googletest/blob/master/googletest/docs/primer.md#test-fixtures-using-the-same-data-configuration-for-multiple-tests</description></item><item><title/><link>https://sysfig.dev/series/c++/z99_abseil/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/c++/z99_abseil/</guid><description>https://github.com/abseil/abseil-cpp</description></item><item><title/><link>https://sysfig.dev/series/c/z99_dump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/c/z99_dump/</guid><description>C Standard Library Glibc uClibC Dietlibc Bionic Musl</description></item><item><title/><link>https://sysfig.dev/series/linux/m99_numa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/linux/m99_numa/</guid><description>https://en.wikipedia.org/wiki/Non-uniform_memory_access https://www.kernel.org/doc/html/v4.18/vm/numa.html</description></item><item><title/><link>https://sysfig.dev/series/linux/m99_sbrk/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/linux/m99_sbrk/</guid><description>sbrk to request more memory</description></item><item><title/><link>https://sysfig.dev/series/linux/z99_dump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/linux/z99_dump/</guid><description>Kernel read-only psuedofilesystems
/sys - used by hardware-related programs /proc -</description></item><item><title/><link>https://sysfig.dev/series/postgres/a00_introduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/a00_introduction/</guid><description>PostgreSQL is an open-source, object-relational database management system (ORDBMS) based on POSTGRES. The POSTGRES project was developed by a team at the University of California at Berkeley Computer Science Department, led by Professor Michael Stonebraker. The project lasted from 1986 to 1994, and its last release was v4.2.
In 1994, Andrew Yu and Jolly Chen rewrote POSTGRES in ANSI C and replaced the original query interpreter (PostQUEL) with a SQL interpreter.</description></item><item><title/><link>https://sysfig.dev/series/postgres/a01_data-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/a01_data-types/</guid><description>Data Types char(N)* - character string of a fixed length (N) varchar(N)* - character string of variable length, up to a maximum (N) int* - integer smallint* real* - floating-point numbers date* - date time* timestamp* interval* double precision* PostgreSQL-specific types
point user-defined data types</description></item><item><title/><link>https://sysfig.dev/series/postgres/s99_dump/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/s99_dump/</guid><description>GROUP BY</description></item><item><title/><link>https://sysfig.dev/series/postgres/z99_function-overloading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_function-overloading/</guid><description/></item><item><title/><link>https://sysfig.dev/series/postgres/z99_functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_functions/</guid><description>Functions Window Functions A window function perform calculations across a window of rows. A window is a set of rows that are, in some way, related to the current row. For example, in a table of students, a window may be the set of students that belong to the same class as the current student.
You can, for example, get the average numeric value for a particular column over a set of rows.</description></item><item><title/><link>https://sysfig.dev/series/postgres/z99_mvcc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_mvcc/</guid><description>https://en.wikipedia.org/wiki/Multiversion_concurrency_control
No read locks.</description></item><item><title/><link>https://sysfig.dev/series/postgres/z99_object-relational-database/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_object-relational-database/</guid><description>Postgres is an object-relational database.</description></item><item><title/><link>https://sysfig.dev/series/postgres/z99_partial-indexes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_partial-indexes/</guid><description>partial indexes - e.g. have an index of posts excluding the soft-deleted ones</description></item><item><title/><link>https://sysfig.dev/series/postgres/z99_psql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_psql/</guid><description>https://www.postgresql.org/docs/current/tutorial-accessdb.html
mydb=&amp;gt; SELECT version(); version -------------------------------------------------------------------​----------------------- PostgreSQL 13.1 on x86_64-pc-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit (1 row) internal commands Internal commands are not SQL commands and they start with \</description></item><item><title/><link>https://sysfig.dev/series/postgres/z99_server-groups/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_server-groups/</guid><description>pgAdmin Server groups is a feature of pgAdmin, completely independent of Postgres. More importantly, server groups are not the same as database clusters.</description></item><item><title/><link>https://sysfig.dev/series/postgres/z99_subqueries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_subqueries/</guid><description/></item><item><title/><link>https://sysfig.dev/series/postgres/z99_table-inheritance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_table-inheritance/</guid><description/></item><item><title/><link>https://sysfig.dev/series/postgres/z99_transactions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_transactions/</guid><description>Transactions A transaction block is an ordered set of SQL commands that are grouped into a single operation. This means if the database crashes whilst executing one of the SQL commands in the transaction, then the whole transaction is deemed to have failed and none of the SQL commands within it (even those that have already been executed) takes effect. Because of this all-or-nothing property, transactions are said to be atomic.</description></item><item><title/><link>https://sysfig.dev/series/postgres/z99_triggers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_triggers/</guid><description>triggers</description></item><item><title/><link>https://sysfig.dev/series/postgres/z99_views/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/postgres/z99_views/</guid><description>Views There are two places you can specify which queries are to be run on the database. The first is in the client code using a client library such as C&amp;rsquo;s libpq. Another is in the database itself in the form of views.
Views are simply named SQL SELECT queries. You can refer to the view (the output of the SELECT query) as a normal table, which means you can even have views that builds on top of other views.</description></item><item><title/><link>https://sysfig.dev/series/programming/m99_memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/programming/m99_memory/</guid><description>Types of Memory Management
Garbage collection (GC) Mark and Sweep Reference Counting - cannot handle cyclic references Resource Acquisition is Initialization (RAII) Automatic Reference Counting (ARC) - also cannot handle cyclic references Ownership - Rust</description></item><item><title/><link>https://sysfig.dev/series/worldbuilding/l99_conlang/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://sysfig.dev/series/worldbuilding/l99_conlang/</guid><description>https://www.vulgarlang.com/</description></item></channel></rss>