<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>software-engineering on sysfig</title><link>https://sysfig.dev/tags/software-engineering/</link><description>Recent content in software-engineering on sysfig</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Mon, 04 Jan 2021 07:26:25 -0800</lastBuildDate><atom:link href="https://sysfig.dev/tags/software-engineering/index.xml" rel="self" type="application/rss+xml"/><item><title>E2E Tests are the Most Important</title><link>https://sysfig.dev/series/hobgoblins-of-little-minds/e2e-tests-most-important/</link><pubDate>Mon, 04 Jan 2021 07:26:25 -0800</pubDate><guid>https://sysfig.dev/series/hobgoblins-of-little-minds/e2e-tests-most-important/</guid><description>End-to-End (E2E) tests are the most important tests for a piece of software because they are the technical implementation of the contract between the software creator and its users. If all your E2E tests pass, then the contract is fulfilled.
Linus Torvalds, the creator and maintainer of Linux, one of the biggest open-source projects, famously said &amp;ldquo;WE DO NOT BREAK USERSPACE!&amp;rdquo; (an opinion which he consistently expresses). He values:
Not breaking the contract between the kernel and user-space programs Don&amp;rsquo;t make changes to the contact that&amp;rsquo;s incompatible with previous contracts Now, I&amp;rsquo;d bet the software you&amp;rsquo;re writing have fewer dependents than the Linux kernel, and you can change the contract more freely, but the purpose of this article is to drill home the point that you should not break contracts.</description></item><item><title>The Allure of New</title><link>https://sysfig.dev/series/hobgoblins-of-little-minds/allure-of-new/</link><pubDate>Thu, 31 Dec 2020 21:02:44 -0800</pubDate><guid>https://sysfig.dev/series/hobgoblins-of-little-minds/allure-of-new/</guid><description>People like new things.
When a developer sees a new technology (let&amp;rsquo;s call it X) on a job description page, or noticed X popping up as a topic on recent Meetups, they may try to convince their managers to use it at work so they can learn it and have experience with it. I mean, who doesn&amp;rsquo;t want 12 years of Kubernetes experience? (You got to get in early!)
But using new technologies is risky.</description></item><item><title>There are No Gods</title><link>https://sysfig.dev/series/hobgoblins-of-little-minds/there-are-no-gods/</link><pubDate>Thu, 31 Dec 2020 17:39:12 -0800</pubDate><guid>https://sysfig.dev/series/hobgoblins-of-little-minds/there-are-no-gods/</guid><description>In many of the companies I&amp;rsquo;ve worked at, there was often one or two developers that everyone hails as an untouchable God with a gifted mind for code. They are usually one of the early hires who&amp;rsquo;ve established a reputation and newcomers just accept it as fact.
Most of the time, this God perception is formed because colleagues are afraid to ask them questions. And they don&amp;rsquo;t ask questions, more often than not, because there&amp;rsquo;s a culture that sees asking (potentially &amp;lsquo;dumb&amp;rsquo;) questions as a sign of weakness.</description></item><item><title>10% Done</title><link>https://sysfig.dev/series/hobgoblins-of-little-minds/10-percent-done/</link><pubDate>Thu, 31 Dec 2020 16:31:04 -0800</pubDate><guid>https://sysfig.dev/series/hobgoblins-of-little-minds/10-percent-done/</guid><description>We often talk about the goal of software engineering as &amp;ldquo;writing applications that work&amp;rdquo;. But, in truth, that&amp;rsquo;s only 10% of it.
It&amp;rsquo;s easy to write a simple clone of Facebook, Amazon, or Airbnb on your own and deploy it on server; but it&amp;rsquo;s difficult to develop a system where many developers can work together effortlessly (distributed version control, code review pair programming), where new features can be added, tested, and deployed quickly (continuous integration, continuous deployment), where developers can be confident things work (tests), where bugs can be detected and resolved quickly (logging, monitoring), where a new developer joining the project can get up to speed quickly (documentation), where the code is performant (benchmarking).</description></item></channel></rss>